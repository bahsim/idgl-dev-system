# Generation and Validation

This document contains the result of the `Genesis` process for our `useDataFetching` hook. It includes the AI-generated `Artifact` and the formal `Validation` checklist, as completed by the IDGL practitioner.

## 1. The Generated Artifact

The following code was generated by the AI based on the `Spec`.

### `useDataFetching.ts`
```typescript
import { useState, useEffect, useCallback } from 'react';

interface State<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

function useDataFetching<T>(url: string): State<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<Error | null>(null);
  const [trigger, setTrigger] = useState<number>(0);

  const refetch = useCallback(() => {
    setTrigger(prev => prev + 1);
  }, []);

  useEffect(() => {
    const controller = new AbortController();
    const { signal } = controller;

    const fetchData = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch(url, { signal });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = await response.json();
        if (!signal.aborted) {
          setData(result);
        }
      } catch (err) {
        if (!signal.aborted) {
          setError(err as Error);
        }
      } finally {
        if (!signal.aborted) {
          setLoading(false);
        }
      }
    };

    fetchData();

    return () => {
      controller.abort();
    };
  }, [url, trigger]);

  return { data, loading, error, refetch };
}

export default useDataFetching;
```

### `useDataFetching.test.ts`
```typescript
import { renderHook, act } from '@testing-library/react-hooks';
import useDataFetching from './useDataFetching';

// Mocking fetch
global.fetch = jest.fn();

const mockFetch = global.fetch as jest.Mock;

describe('useDataFetching', () => {
  beforeEach(() => {
    mockFetch.mockClear();
  });

  it('TR1: should return the correct initial state', () => {
    const { result } = renderHook(() => useDataFetching('test-url'));

    expect(result.current.data).toBeNull();
    expect(result.current.loading).toBe(true);
    expect(result.current.error).toBeNull();
    expect(typeof result.current.refetch).toBe('function');
  });

  it('TR2: should fetch data and enter the success state', async () => {
    const mockData = { message: 'success' };
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockData,
    });

    const { result, waitForNextUpdate } = renderHook(() => useDataFetching('test-url'));

    await waitForNextUpdate();

    expect(result.current.loading).toBe(false);
    expect(result.current.data).toEqual(mockData);
    expect(result.current.error).toBeNull();
  });

  it('TR3: should handle a failed request and enter the error state', async () => {
    const errorMessage = 'HTTP error! status: 500';
    mockFetch.mockResolvedValueOnce({
      ok: false,
      status: 500,
    });

    const { result, waitForNextUpdate } = renderHook(() => useDataFetching('test-url'));

    await waitForNextUpdate();

    expect(result.current.loading).toBe(false);
    expect(result.current.data).toBeNull();
    expect(result.current.error).toBeInstanceOf(Error);
    expect(result.current.error?.message).toBe(errorMessage);
  });
  
  it('TR4: should manage the loading state correctly', async () => {
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({}),
    });
    
    const { result, waitForNextUpdate } = renderHook(() => useDataFetching('test-url'));
    
    expect(result.current.loading).toBe(true);
    
    await waitForNextUpdate();
    
    expect(result.current.loading).toBe(false);
  });

  it('TR5: should refetch data when refetch is called', async () => {
    const firstMockData = { message: 'first' };
    const secondMockData = { message: 'second' };

    mockFetch.mockResolvedValueOnce({ ok: true, json: async () => firstMockData });

    const { result, waitForNextUpdate } = renderHook(() => useDataFetching('test-url'));

    await waitForNextUpdate();
    expect(result.current.data).toEqual(firstMockData);

    mockFetch.mockResolvedValueOnce({ ok: true, json: async () => secondMockData });
    
    act(() => {
      result.current.refetch();
    });

    expect(result.current.loading).toBe(true);
    await waitForNextUpdate();

    expect(result.current.loading).toBe(false);
    expect(result.current.data).toEqual(secondMockData);
  });

  it('TR6: should cancel the request on unmount', async () => {
    const abortSpy = jest.spyOn(AbortController.prototype, 'abort');
    
    const { unmount } = renderHook(() => useDataFetching('test-url'));

    unmount();

    expect(abortSpy).toHaveBeenCalledTimes(1);
    abortSpy.mockRestore();
  });
});
```

## 2. Validation Checklist

The practitioner has validated the generated artifact against the `Spec`. All criteria have been met.

### 3.1. Functional Requirements
- [x] **FR1: Signature:** The hook must have the signature `useDataFetching<T>(url: string): State<T>`.
- [x] **FR2: Generic Type:** The hook must accept a generic type `T` that defines the expected shape of the data.
- [x] **FR3: State Interface:** The hook must return an object that conforms to the `State<T>` interface.
- [x] **FR4: Initial State:** On initial render, the hook must return `{ data: null, loading: true, error: null, refetch: [function] }`.
- [x] **FR5: Success State:** Upon a successful API response, the hook must update its state to `{ data: [response data], loading: false, error: null, ... }`.
- [x] **FR6: Error State:** If the network request fails, the hook must update its state to `{ data: null, loading: false, error: [Error object], ... }`.
- [x] **FR7: Refetch Functionality:** The returned `refetch` function, when called, must re-trigger the data fetching process.

### 3.2. Non-Functional Requirements
- [x] **NFR1: Cleanup:** The hook must clean up any pending `fetch` requests when the component unmounts.
- [x] **NFR2: Race Condition Prevention:** The hook must be robust against race conditions.

### 3.3. Testing Requirements
- [x] **TR1: Initial State:** The hook returns the correct initial state.
- [x] **TR2: Success Case:** The hook correctly fetches data and enters the success state.
- [x] **TR3: Error Case:** The hook correctly handles a failed request and enters the error state.
- [x] **TR4: Loading State:** The `loading` flag is correctly managed.
- [x] **TR5: Refetch Logic:** The `refetch` function correctly re-triggers a data fetch.
- [x] **TR6: Unmount Cleanup:** The hook correctly cancels pending requests when the component unmounts.
