# AST Parser Output Format Specification

## Overview
This document provides a complete, transparent specification of the output format generated by our TypeScript AST Parser. Each field is documented with its content, data source, and collection method.

## Output Structure

### Root Level
```json
{
  "metadata": { ... },
  "patterns": [ ... ],
  "errors": [ ... ],
  "stats": { ... }
}
```

## Pattern Object Structure

### Core Identification Fields

#### `id: string`
- **Content**: Unique identifier for the pattern
- **Format**: `{functionName}-{hash}`
- **Source**: Generated by combining function name with content hash
- **Method**: `generatePatternHash()` - creates SHA-256 hash of node content

#### `name: string`
- **Content**: Name of the function/component/interface
- **Source**: Extracted from AST node
- **Method**: `getNodeName()` - reads `node.name.text` or parent context
- **Examples**: `"Button"`, `"useCounter"`, `"UserProps"`

#### `type: PatternType`
- **Content**: Classification of the pattern
- **Values**: `'react-component' | 'custom-hook' | 'utility-function' | 'type-definition' | 'interface' | 'enum' | 'constant'`
- **Source**: Determined by analyzing node structure and naming
- **Method**: `determineFunctionType()` - uses naming conventions and JSX detection

#### `filePath: string`
- **Content**: Full path to the source file
- **Source**: TypeScript SourceFile object
- **Method**: `getNodeLocation()` - reads `sourceFile.fileName`

#### `lineNumber: number`
- **Content**: Line number where pattern starts (1-indexed)
- **Source**: TypeScript SourceFile position
- **Method**: `getNodeLocation()` - calls `sourceFile.getLineAndCharacterOfPosition(node.getStart())`

#### `columnNumber: number`
- **Content**: Column number where pattern starts (1-indexed)
- **Source**: TypeScript SourceFile position
- **Method**: `getNodeLocation()` - calls `sourceFile.getLineAndCharacterOfPosition(node.getStart())`

#### `hash: string`
- **Content**: SHA-256 hash of the pattern's content
- **Source**: Generated from node text content
- **Method**: `generatePatternHash()` - hashes `node.getText()`

### Metadata Fields

#### `metadata.complexity: number`
- **Content**: Cyclomatic complexity score
- **Source**: AST traversal counting control structures
- **Method**: `calculateComplexity()` - counts if/for/while/switch/catch statements
- **Range**: 1+ (minimum 1 for any function)

#### `metadata.parameters: ParameterInfo[]`
- **Content**: Function parameter information
- **Source**: Extracted from function signature
- **Method**: `extractParameters()` - reads `node.parameters` array
- **Structure**:
  ```typescript
  {
    name: string,        // Parameter name or 'param' if anonymous
    type: string,        // Type annotation or 'any' if missing
    required: boolean    // true if no questionToken
  }
  ```

#### `metadata.returnType: string`
- **Content**: Function return type
- **Source**: TypeScript type checker or explicit annotations
- **Method**: `extractTypeInformation()` - uses `typeChecker.getTypeFromTypeNode()`
- **Fallback**: `'any'` if type cannot be determined

#### `metadata.isExported: boolean`
- **Content**: Whether the pattern is exported
- **Source**: AST analysis of export statements
- **Method**: `isExported()` - comprehensive export detection
- **Checks**:
  - Export modifiers on declaration
  - Named exports: `export { ComponentName }`
  - Default exports: `export default Component`
  - Re-exports: `export { ComponentName } from './path'`

#### `metadata.isDefault: boolean`
- **Content**: Whether this is a default export
- **Source**: AST analysis of export statements
- **Method**: `isDefaultExport()` - checks for `export default` syntax
- **Detection**: Pattern matching in surrounding text

#### `metadata.exportType: string`
- **Content**: Type of export
- **Values**: `'named' | 'default' | 're-export' | 'none'`
- **Source**: Export statement analysis
- **Method**: `getExportDetails()` - classifies export patterns

#### `metadata.exportName: string | null`
- **Content**: Name used in export statement
- **Source**: Export declaration analysis
- **Method**: `getExportDetails()` - extracts from export specifiers

#### `metadata.exportPath: string | null`
- **Content**: Module path for re-exports
- **Source**: Export declaration module specifier
- **Method**: `getExportDetails()` - reads `n.moduleSpecifier.text`

#### `metadata.isReExported: boolean`
- **Content**: Whether this is re-exported from another module
- **Source**: Export declaration analysis
- **Method**: `getExportDetails()` - checks for module specifier

#### `metadata.jsxReturnType: boolean`
- **Content**: Whether function returns JSX
- **Source**: AST traversal looking for JSX elements
- **Method**: `hasJSXReturn()` - visits all child nodes for JSX patterns

#### `metadata.genericTypes: string[]`
- **Content**: Generic type parameter names
- **Source**: TypeScript type parameters
- **Method**: `extractTypeInformation()` - reads `node.typeParameters`
- **Example**: `["T", "U"]` for `function<T, U>()`

#### `metadata.propTypes: Record<string, string>`
- **Content**: React prop type information
- **Source**: Interface analysis and inline types
- **Method**: `extractPropTypes()` - searches for Props interfaces
- **Structure**:
  ```typescript
  {
    "hasPropsInterface": boolean,
    "propsInterfaceName": string,
    "inlineProps": boolean,
    "propsType": string
  }
  ```

#### `metadata.usageCount: number`
- **Content**: Number of times pattern is used in same file
- **Source**: AST traversal counting references
- **Method**: `calculateUsageCount()` - counts identifiers, excludes declarations
- **Note**: Excludes self-reference, imports, exports

#### `metadata.lastModified: Date`
- **Content**: Timestamp of analysis
- **Source**: Current system time
- **Method**: `new Date()` - generated during analysis
- **Note**: Not actual file modification time (future enhancement)

#### `metadata.purpose: string`
- **Content**: Pattern purpose classification
- **Values**: `'UI' | 'Logic' | 'Data' | 'Utility'`
- **Source**: AST analysis of content and naming
- **Method**: `determinePurpose()` - uses heuristics:
  - JSX return → 'UI'
  - Hook patterns → 'Logic'
  - Interface/type → 'Data'
  - Default → 'Utility'

#### `metadata.architecturalMetrics: object`
- **Content**: Code quality metrics
- **Source**: Calculated from AST analysis
- **Method**: Various calculation methods

##### `metadata.architecturalMetrics.coupling: number`
- **Content**: Dependency coupling score (0-10)
- **Source**: Import statements, function calls, property access
- **Method**: `calculateCoupling()` - counts external dependencies
- **Formula**: +2 for imports, +1 for external calls, +0.5 for property access

##### `metadata.architecturalMetrics.cohesion: number`
- **Content**: Single responsibility score (1-10)
- **Source**: Control flow analysis
- **Method**: `calculateCohesion()` - starts at 10, deducts for complexity
- **Formula**: 10 - 0.5×returns - 0.2×binaryOps - 0.3×controlStructures

##### `metadata.architecturalMetrics.abstraction: number`
- **Content**: Abstraction level score (1-10)
- **Source**: Generic types, interfaces, abstract methods
- **Method**: `calculateAbstraction()` - starts at 5, adds for abstractions
- **Formula**: 5 + generics + interfaces + abstractMethods

##### `metadata.architecturalMetrics.complexity: number`
- **Content**: Cyclomatic complexity (same as metadata.complexity)
- **Source**: Control structure counting
- **Method**: `calculateComplexity()` - identical to root complexity

##### `metadata.architecturalMetrics.maintainability: number`
- **Content**: Maintainability index (0-100)
- **Source**: Calculated from other metrics
- **Method**: `100 - complexity - coupling`
- **Note**: Simplified formula, not industry standard

#### `metadata.dependencies: string[]`
- **Content**: Import dependencies
- **Source**: Import declaration analysis
- **Method**: `extractDependencies()` - visits AST for import statements
- **Format**: Module specifier strings (e.g., `'react'`, `'./utils'`)

### Export Information

#### `exports: ExportInfo[]`
- **Content**: Detailed export information array
- **Source**: Export statement analysis
- **Method**: `getExportDetails()` - comprehensive export detection
- **Structure**:
  ```typescript
  {
    "type": string,      // 'named', 'default', 're-export'
    "name": string,      // Export name
    "path": string,      // Module path for re-exports
    "isReExport": boolean // Re-export flag
  }
  ```

## Data Collection Methods

### AST Traversal
- **Tool**: TypeScript Compiler API
- **Method**: `ts.forEachChild()` recursive traversal
- **Scope**: File-level analysis

### Type Information
- **Tool**: TypeScript Type Checker
- **Method**: `typeChecker.getTypeFromTypeNode()`
- **Fallback**: `'any'` if type resolution fails

### Position Information
- **Tool**: TypeScript SourceFile
- **Method**: `getLineAndCharacterOfPosition()`
- **Note**: 0-indexed internally, converted to 1-indexed for output

### Pattern Classification
- **Method**: Heuristic analysis
- **Factors**: Naming conventions, JSX presence, hook patterns
- **Limitation**: Uses simplified rules, not ML-based classification

### Quality Metrics
- **Method**: Calculated formulas
- **Basis**: AST structure analysis
- **Limitation**: Simplified scoring, not industry-standard metrics

## Limitations and Assumptions

### Type Resolution
- **Assumption**: TypeScript project has valid configuration
- **Fallback**: `'any'` type when resolution fails
- **Impact**: Some type information may be generic

### Export Detection
- **Scope**: File-level analysis only
- **Limitation**: Cannot detect cross-file export references
- **Method**: Text pattern matching for complex cases

### Quality Metrics
- **Basis**: Simplified heuristics
- **Standard**: Not industry-standard (e.g., McCabe complexity)
- **Accuracy**: Approximate, not precise measurements

### Performance Impact
- **Complexity**: O(n) for each file
- **Memory**: AST held in memory during analysis
- **Scalability**: Linear with file size and complexity

## Future Enhancements

### Planned Improvements
1. **Git Integration**: Real file modification timestamps
2. **Cross-File Analysis**: Export/import relationship mapping
3. **Industry Standards**: McCabe complexity, Halstead metrics
4. **ML Classification**: Pattern purpose classification
5. **Dependency Graphs**: Module relationship visualization

### Research Areas
1. **Performance Optimization**: Incremental parsing
2. **Accuracy Improvement**: Better type resolution
3. **Metric Validation**: Industry standard compliance
4. **Pattern Recognition**: Advanced React pattern detection

## Conclusion

This specification provides complete transparency into our output format. Every field is documented with its source, collection method, and limitations. The parser prioritizes **comprehensive coverage** over **perfect accuracy**, using heuristics and simplified calculations to provide meaningful insights while maintaining performance.

**Key Principle**: We prefer to provide **approximate but comprehensive** data rather than **precise but incomplete** information.
