# Итоговый отчёт: Эволюция системы компиляции Spec-документов в IDGL

## 1. Краткое резюме

В данном отчете задокументированы проектирование и эволюция практической, масштабируемой системы для реализации Жизненного цикла генеративной разработки, управляемой намерениями (IDGL). Изначальная цель заключалась в создании одного конкретного примера задачи рефакторинга, выполняемой под управлением `Spec`-документа IDGL. Однако в ходе строгого итеративного процесса разработки, критического анализа и усовершенствования проект трансформировался в создание сложной, автоматизированной системы "компиляции Spec-документов" профессионального уровня. Эта система значительно снижает участие человека, одновременно обеспечивая соблюдение лучших инженерных практик. Ключевыми результатами стали формализация трех основных паттернов: **Компиляция Spec-документов (Spec Compilation)**, **Тесты по умолчанию (Tests by Default)** и **Компонуемые промпты (Composable Prompts)**. Конечным итогом является не просто пример, а полноценный, хорошо спроектированный и самодокументирующийся фреймворк для применения философии IDGL к реальным задачам разработки.

## 2. Исходная цель

Проект начинался со скромной и ясной цели: создать "демонстрационный проект", который послужил бы наглядным практическим примером рабочего процесса IDGL. Была выбрана распространенная задача: рефакторинг компонента React с извлечением встроенной логики в отдельную утилитарную функцию. Первоначальное намерение состояло в том, чтобы вручную составить формальный `Spec`-документ, а затем сгенерировать соответствующий код для демонстрации ключевых принципов IDGL.

## 3. Описание процесса и путь к открытиям

Путь от исходной цели до финальной системы был полон постоянных открытий и архитектурных усовершенствований.

**Этап 1: «Избыточно спроектированный» подход.** Первая реализация представляла собой прямолинейное, «каноническое» применение декомпозиции задач. Мы создали три отдельных `Spec`-файла для трех различных шагов: анализ кода, генерация новой утилиты и модификация исходного компонента. Такой подход был немедленно признан чрезмерно бюрократическим и непрактичным для задачи такого масштаба. Он демонстрировал *механику* IDGL, но не отражал *дух* эффективного рабочего процесса.

**Этап 2: «Консолидированный Spec» и человеческий фактор как узкое место.** Затем процесс был переработан с использованием единого, всеобъемлющего `Spec`-документа, который определял всю задачу рефакторинга в одном файле. Хотя это было значительным улучшением, оно выявило более глубокий недостаток: сам `Spec`-документ, с его подробными контрольными списками и формальной структурой, оставался слишком многословным и громоздким для ручного написания человеком в рамках повседневных задач. Это стало критическим озарением: разработчик-человек превратился в узкое место.

**Этап 3: Архитектурный прорыв — «Компиляция Spec».** Осознание того, что человек не должен писать финальный `Spec`-документ, привело к ключевому архитектурному прорыву проекта: паттерну **«Компиляция Spec-документов» (Spec Compilation)**. Мы переопределили роли:
*   **Человек:** Составляет краткое, высокоуровневое, неформальное **Задание (Brief)**.
*   **ИИ («Компилятор Spec»):** Получает `Задание` и контекст кода, а затем выполняет работу по генерации формального `Spec`-документа.

**Этап 4: Эволюция инструментария.** Для поддержки этого нового паттерна мы начали создавать скрипт `assemble-spec-prompt.ps1`. Этот инструмент сам прошел быструю эволюцию на основе постоянного критического анализа:
1.  Он начинался как жестко закодированная заглушка.
2.  Затем он превратился в простой шаблонизатор с негибким, жестко закодированным промптом.
3.  Далее он был переработан для вынесения шаблона промпта во внешний `.md` файл с использованием простых плейсхолдеров.
4.  Система была усовершенствована до компонуемой, где скрипт выступал в роли «препроцессора», способного разрешать директивы `@import` для объединения основного шаблона с переиспользуемыми `_partials`.
5.  Наконец, ключевая логика препроцессинга была **инкапсулирована** в собственный переиспользуемый модуль (`idgl-template-engine.ps1`), превратив основной скрипт в чистого, сфокусированного «потребителя» этого движка.

**Этап 5: Принцип «Тесты по умолчанию».** В ходе эволюции инструментария был выявлен системный риск: система, которая полагается на то, что человек не забудет запросить модульные тесты, по своей сути несовершенна. Это привело к утверждению принципа **«Тесты по умолчанию» (Tests by Default)**. Основной шаблон промпта был обновлен, чтобы явно инструктировать ИИ-«Компилятор Spec» *всегда* включать комплексный план тестирования в каждый генерируемый им `Spec`, делая качество необсуждаемой, автоматизированной частью процесса.

## 4. Финальная архитектура системы

Финальная система представляет собой хорошо спроектированный, слабосвязанный фреймворк для генерации `Spec`-документов экспертного уровня.
*   **`idgl-template-engine.ps1`:** Переиспользуемый, инкапсулированный модуль PowerShell, содержащий ключевую логику для компиляции шаблонов промптов путем разрешения директив `@import`.
*   **`prompt-templates/`:** Директория, содержащая компонуемые шаблоны промптов в формате Markdown. Переиспользуемые компоненты (например, системная преамбула) хранятся в `_partials/`, а основные шаблоны (например, `spec-compiler.md`) их импортируют.
*   **`assemble-spec-prompt.ps1`:** Компактный скрипт-«потребитель», использующий движок шаблонов. Его задача — принять `Задание` от пользователя и контекст кода, указать на основной шаблон и организовать генерацию финального, полного промпта для ИИ.
*   **Рабочий процесс:** Человек предоставляет простое `Задание`, а скрипт собирает промпт экспертного уровня. ИИ выполняет этот промпт для создания `Spec`-документа, включающего как критерии реализации, так и план тестирования. Второй ИИ (или человек) затем выполняет этот `Spec` для получения финального, валидированного кода.

## 5. Выделенные паттерны

*   **Паттерн «Компиляция Spec» (The "Spec Compilation" Pattern):** Двухуровневая система, в которой `Задание` от человека компилируется в формальный `Spec` с помощью ИИ. Это ключевой стратегический паттерн для практического применения IDGL.
*   **Паттерн «Тесты по умолчанию» (The "Tests by Default" Pattern):** Принцип встраивания необсуждаемых критериев качества (таких как генерация модульных тестов) непосредственно в основные инструкции системы.
*   **Паттерн «Компонуемые промпты» (The "Composable Prompts" Pattern):** Технический паттерн использования препроцессора и системы `@import` для применения принципа DRY к инженерии промптов, обеспечивая масштабируемое и поддерживаемое управление промптами.

## 6. Заключение

Проект `01-react-refactor-with-tests` увенчался успехом, далеко превзошедшим его первоначальные цели. Он не просто создал пример, а произвел переиспользуемый фреймворк профессионального уровня для генерации `Spec`-документов, который воплощает высшие принципы философии IDGL. Финальная система является свидетельством мощи итеративного проектирования и строгого критического анализа, результатом которого стал рабочий процесс, одновременно эффективный для людей, понятный для ИИ и надежный по своей сути.
