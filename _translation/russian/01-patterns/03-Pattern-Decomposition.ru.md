# Паттерн: Декомпозиция

## 1. Суть Паттерна
Подход Архитектора по умолчанию — это **Принцип Максимального Охвата**: генерировать самый большой возможный блок работы, который все еще можно строго проверить.

Однако некоторые задачи слишком велики или сложны для этого принципа. **Паттерн Декомпозиции** — это стратегия Архитектора для таких ситуаций. Это намеренное и минимальное разделение одного высокоуровневого намерения на небольшое количество существенных, независимо проверяемых генеративных задач.

Декомпозиция — это исключение, а не правило. Это стратегический компромисс, принимающий повышенные накладные расходы на координацию в обмен на управляемую валидацию и снижение рисков.

## 2. Когда Применять Паттерн
Архитектор применяет этот паттерн, когда одна генеративная задача невыполнима. Признаки очевидны:

*   **Предел Возможностей:** Задача превышает контекстное окно ИИ.
*   **Предел Валидации:** Сгенерированный вывод слишком велик или сложен для надежной проверки человеком (например, >500 строк или >30 минут на проверку).
*   **Разделение Труда:** Работа требует участия разных экспертов для валидации (например, специалиста по базам данных и UI-дизайнера).
*   **Изоляция Рисков:** Критически важный компонент должен быть сгенерирован и проверен независимо, прежде чем можно будет приступить к зависимой работе.

## 3. Как Применять Паттерн
Это совместный процесс, в котором Архитектор руководит агентом ИИ для создания плана.

### Шаг 1: Директива Архитектора
Архитектор просит ИИ выступить в роли партнера по планированию, предлагая ему план декомпозиции на основе высокоуровневой цели.

> **Пример Директивы:**
> «Моя цель — „Рефакторинг монолитного UI-компонента на более мелкие, тестируемые подкомпоненты“. Компонент занимает ~800 строк. Ваша задача — выступить в роли старшего архитектора программного обеспечения. Предложите детальный план декомпозиции. Для каждой подзадачи определите ее входы, выходы и критерии валидации. Представьте план в виде диаграммы Mermaid и подробного списка спецификаций задач».

### Шаг 2: План, Сгенерированный ИИ
ИИ анализирует запрос и генерирует кандидатский план декомпозиции, включая диаграмму и список задач.

### Шаг 3: Суждение Архитектора
Это критически важная роль Архитектора. Он рассматривает и проверяет предложенный ИИ план, либо утверждая его, либо предоставляя обратную связь для уточнения. Этот цикл продолжается до тех пор, пока Архитектор не будет удовлетворен.

> **Пример Уточнения:**
> «Общая структура хороша, но контракты между новыми подкомпонентами определены недостаточно четко. Обновите план, включив в него шаг, который выводит формальную JSON-спецификацию, определяющую точные пропсы и интерфейсы для каждого нового компонента. Все последующие задачи должны использовать эту спецификацию в качестве своего основного входного контракта».

## 4. Критический Выбор: Кто Исполняет?
После утверждения плана Архитектор делает стратегический выбор: кто выполняет подзадачи?

1.  **ИИ как Исполнитель:** Путь по умолчанию для рутинных задач, где скорость является основным фактором.
2.  **Архитектор как Исполнитель:** Предпочтительный выбор для задач, где долгосрочное владение, глубокое обучение и тонкая реализация важнее, чем чистая скорость. Архитектор использует сгенерированный ИИ план как первоклассный чертеж для руководства своей практической работой по кодированию.

Этот выбор является осознанным актом инженерного суждения.

## 5. Правила Взаимодействия
*   **Держитесь неглубоко:** Хорошая декомпозиция является неглубокой (максимум 1-2 уровня).
*   **Определяйте явные контракты:** Каждая подзадача должна иметь свою полную `Спецификацию` и стабильную границу (например, API, схему данных, интерфейс компонента).
*   **Выполняйте последовательно или параллельно:** Для задач с прямыми зависимостями связывайте их последовательно. Для независимой работы используйте параллельный подход с разветвлением и слиянием, но только после определения стабильного интеграционного контракта.
*   **Избегайте микро-декомпозиции:** Не разбивайте задачи на тривиальные части (<100 строк или <15 минут на валидацию). Это создает больше накладных расходов, чем экономит.

---
*Этот паттерн демонстрируется в примерах проектов `01-react-refactor-with-tests` и `03-nestjs-sample`.*
